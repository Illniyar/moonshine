var when = require("when"),
    sequence = require("when/sequence"),
    nodefn = require("when/node/function")

var ExtensionLoader = module.exports =function ExtensionLoader(components,logger,options){
    this.logger = logger;
    this.components = components;
    this.options = options || {}
    this.options.masterModuleName = this.options.masterModuleName || "extension"
}
ExtensionLoader.prototype.applyExtensionFunction =function(name) {
    var promises = []
    var self = this;
    var args = Array.prototype.slice.call(arguments,1)
    try {
        this.components.forEach(function(comp){
            var func = self.getExtensionFunction(comp,name)
            if (func) promises.push(nodefn.lift(func))
        })
    } catch (e) {
        return when.reject(e)
    }
    return sequence(promises)
}
ExtensionLoader.prototype.applySetupFunction =function(name) {
    var promises = []
    var self = this;
    var args = Array.prototype.slice.call(arguments,1)
    try {
        this.components.forEach(function(comp){
            //this complicated loading sequence is so that we won't require
            //modules until they are loaded for setup
            // so that you could access services in the start of an extension
            var filename = self.getExtensionFunction(comp,name,true)
            if (filename) promises.push(nodefn.lift(function(cb){
                try {
                    var module = comp.require(filename)
                    if (module[name])
                        module[name](cb)
                    else if (filename.indexOf(self.options.masterModuleName + "." + name) >=0) {
                        module(cb)
                    } else {
                        cb()
                    }
                } catch (e){
                    cb(e)
                }
            }))
        })
    } catch (e) {
        return when.reject(e)
    }
    return sequence(promises)
}
function checkForModule(component,moduleName,resolveOnly) {
    try {
        if (resolveOnly) return component.require.resolve("./" + moduleName)
        return component.require("./" + moduleName)
    } catch (e) {
        if (e.code && e.code == "MODULE_NOT_FOUND" ){
            return null
        } else {
            throw e
        }
    }
}
ExtensionLoader.prototype.getExtensionFunction = function(component,name,resolveOnly) {
    var namedExtensionModule = checkForModule(component,this.options.masterModuleName + "." + name,resolveOnly)
    if (namedExtensionModule) return namedExtensionModule
    var masterModule = checkForModule(component,this.options.masterModuleName,resolveOnly)
    if (masterModule && resolveOnly) return masterModule
    if (masterModule && masterModule[name]) return masterModule[name]
    return null;

}
ExtensionLoader.prototype.applyExtensionProcessor =function(name,before,foreach,after) {
    if (!before) before = "before";
    if (!foreach) foreach = "process";
    if (!after) after = "after";
    var self = this;
    var promises = []
    try {
        this.components.forEach(function(comp){
            var masterModule = checkForModule(comp,self.options.masterModuleName)
            if(masterModule && masterModule[name]) {
                promises.push(function(){
                    self.logger.debug("applying extension: " + comp.filename)
                })
                var extension = masterModule[name]
                if (extension[before])  promises.push(nodefn.lift(extension[before]))
                if (extension[foreach]) {
                    self.components.forEach(function(item){
                        promises.push(nodefn.lift(extension[foreach],item))
                    })
                }
                if(extension[after]) promises.push(nodefn.lift(extension[after]))
            }
        })
    } catch (e) {
        return when.reject(e)
    }
    return sequence(promises)
}
ExtensionLoader.prototype.findCommand = function(commandName) {
    for (var i =0; i < this.components.length;i++) {
        var comp = this.components[i]
        var command = checkForModule(comp,"commands/" + commandName)
        if (!command) {
            var commands =  checkForModule(comp,"commands")
            if (commands) command = commands[commandName]
        }
        if (command) return command;
    }
    return null;
}